using System;
using System.Collections.Generic;

namespace lox
{
    /// <summary>
    /// Performs static analysis on the AST generated by <see cref="Parser"/>. 
    /// </summary>
    public class Resolver : Expr.IVisitor<object?>,
                            Stmt.IVisitor<Void>
    {
        #region Fields

        private readonly Interpreter interpreter;

        private readonly Stack<Dictionary<string, bool>> scopes;

        #endregion

        #region Constructors

        public Resolver(Interpreter interpreter)
        {
            this.interpreter = interpreter ?? throw new ArgumentNullException(nameof(interpreter));
            this.scopes = new Stack<Dictionary<string, bool>>();
        }

        #endregion

        #region Instance Methods

        public void Resolve(List<Stmt> stmts,
                            in ReadOnlySpan<char> source)
        {
            for (int i = 0;
                 i < stmts.Count;
                 i++)
            {
                this.Resolve(stmts[i],
                             source);
            }
        }

        public object? VisitAssignExpr(Expr.Assign expr,
                                       in ReadOnlySpan<char> source)
        {
            this.Resolve(expr.value,
                         source);
            this.ResolveLocal(expr,
                              expr.name,
                              source);
            return default;
        }

        public object? VisitBinaryExpr(Expr.Binary expr,
                                       in ReadOnlySpan<char> source)
        {
            this.Resolve(expr.left,
                         source);
            this.Resolve(expr.right,
                         source);
            return default;
        }

        public Void VisitBlockStmt(Stmt.Block stmt,
                                   in ReadOnlySpan<char> source)
        {
            this.BeginScope();
            this.Resolve(stmt.statements,
                         source);
            this.EndScope();
            return default;
        }

        public object? VisitCallExpr(Expr.Call expr,
                                     in ReadOnlySpan<char> source)
        {
            this.Resolve(expr.callee,
                         source);

            for (int i = 0;
                 i < expr.arguments.Count;
                 i++)
            {
                this.Resolve(expr.arguments[i],
                             source);
            }

            return default;
        }

        public Void VisitExpressionStmt(Stmt.Expression stmt,
                                        in ReadOnlySpan<char> source)
        {
            this.Resolve(stmt.expression,
                         source);
            return default;
        }

        public Void VisitFunctionStmt(Stmt.Function stmt,
                                      in ReadOnlySpan<char> source)
        {
            this.Declare(stmt.name,
                         source);
            this.Define(stmt.name,
                        source);

            this.ResolveFunction(stmt,
                                 source);
            return default;
        }

        public object? VisitGroupingExpr(Expr.Grouping expr,
                                         in ReadOnlySpan<char> source)
        {
            this.Resolve(expr.expression,
                         source);
            return default;
        }

        public Void VisitIfStmt(Stmt.If stmt,
                                in ReadOnlySpan<char> source)
        {
            this.Resolve(stmt.condition,
                         source);
            this.Resolve(stmt.thenBranch,
                         source);
            if (stmt.elseBranch != null)
            {
                this.Resolve(stmt.elseBranch,
                             source);
            }

            return default;
        }

        public object? VisitLiteralExpr(Expr.Literal expr,
                                        in ReadOnlySpan<char> source)
        {
            return default;
        }

        public object? VisitLogicalExpr(Expr.Logical expr,
                                        in ReadOnlySpan<char> source)
        {
            this.Resolve(expr.left,
                         source);
            this.Resolve(expr.right,
                         source);
            return default;
        }

        public Void VisitPrintStmt(Stmt.Print stmt,
                                   in ReadOnlySpan<char> source)
        {
            this.Resolve(stmt.expression,
                         source);
            return default;
        }

        public Void VisitReturnStmt(Stmt.Return stmt,
                                    in ReadOnlySpan<char> source)
        {
            if (stmt.value != null)
            {
                this.Resolve(stmt.value,
                             source);
            }

            return default;
        }

        public object? VisitUnaryExpr(Expr.Unary expr,
                                      in ReadOnlySpan<char> source)
        {
            this.Resolve(expr.right,
                         source);
            return default;
        }

        public object? VisitVariableExpr(Expr.Variable expr,
                                         in ReadOnlySpan<char> source)
        {
            if (this.scopes.Count > 0)
            {
                var scope = this.scopes.Peek();
                var name = expr.name.GetLexeme(source)
                               .ToString();
                if (scope.TryGetValue(name,
                                      out bool defined))
                {
                    if (!defined)
                    {
                        Lox.Error(expr.name.Line,
                                  $"Cannot read local variable '{name}' in its own initializer");
                        return default;
                    }
                }
            }

            this.ResolveLocal(expr,
                              expr.name,
                              source);
            return default;
        }

        public Void VisitVarStmt(Stmt.Var stmt,
                                 in ReadOnlySpan<char> source)
        {
            this.Declare(stmt.name,
                         source);

            if (stmt.initializer != null)
            {
                this.Resolve(stmt.initializer,
                             source);
            }

            this.Define(stmt.name,
                        source);
            return default;
        }

        public Void VisitWhileStmt(Stmt.While stmt,
                                   in ReadOnlySpan<char> source)
        {
            this.Resolve(stmt.condition,
                         source);
            this.Resolve(stmt.statement,
                         source);
            return default;
        }

        private void BeginScope()
        {
            this.scopes.Push(new Dictionary<string, bool>());
        }

        private void Declare(Token name,
                             in ReadOnlySpan<char> source)
        {
            if (this.scopes.Count == 0)
            {
                return;
            }

            Dictionary<string, bool> scope = this.scopes.Peek();
            scope[name.GetLexeme(source)
                      .ToString()] = false;
        }

        private void Define(Token name,
                            in ReadOnlySpan<char> source)
        {
            if (this.scopes.Count == 0)
            {
                return;
            }

            Dictionary<string, bool> scope = this.scopes.Peek();
            scope[name.GetLexeme(source)
                      .ToString()] = true;
        }

        private void EndScope()
        {
            this.scopes.Pop();
        }

        private void Resolve(Stmt stmt,
                             in ReadOnlySpan<char> source)
        {
            stmt.Accept(this,
                        source);
        }

        private void Resolve(Expr expr,
                             in ReadOnlySpan<char> source)
        {
            expr.Accept(this,
                        source);
        }

        private void ResolveFunction(Stmt.Function stmt,
                                     in ReadOnlySpan<char> source)
        {
            this.BeginScope();

            for (int i = 0;
                 i < stmt.parameters.Count;
                 i++)
            {
                this.Declare(stmt.parameters[i],
                             source);
                this.Define(stmt.parameters[i],
                            source);
            }

            this.Resolve(stmt.body,
                         source);

            this.EndScope();
        }

        private void ResolveLocal(Expr expr,
                                  Token exprName,
                                  in ReadOnlySpan<char> source)
        {
            var tempScopes = new Stack<Dictionary<string, bool>>();

            try
            {
                int scopesCount = this.scopes.Count;
                string name = exprName.GetLexeme(source)
                                      .ToString();

                for (int i = scopesCount - 1;
                     i >= 0;
                     i--)
                {
                    var tempScope = this.scopes.Pop();
                    tempScopes.Push(tempScope);

                    if (tempScope.ContainsKey(name))
                    {
                        this.interpreter.Resolve(expr,
                                                 scopesCount - 1 - i);
                        return;
                    }
                }
            }
            finally
            {
                while (tempScopes.TryPop(out Dictionary<string, bool>? tempScope))
                {
                    this.scopes.Push(tempScope);
                }
            }
        }

        #endregion
    }
}